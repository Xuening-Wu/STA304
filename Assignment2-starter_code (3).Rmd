---
title: "ADD A DESCRIPTIVE TITLE"
author: "GROUP NUMBER: ADD YOUR NAMES HERE"
subtitle: "STA304 - Fall 2023 -Assignment 2"
date: "Insert Date Here"
output:
  pdf_document: default
---


```{r, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
#install.packages("report")
library(report)   
library(sjPlot)
library(openintro)
library(tidyverse)
library(lme4)
library(haven)
library(ggplot2)
library(broom)
library(dplyr)
library(knitr)
load('ces2021.RData')
census_data <- read_csv("gss_clean.csv")
```

## Introduction

<Here you should have a few paragraphs of text introducing the problem, getting the reader interested/ready for the rest of the report.>

<Introduce terminology.>

<Highlight hypotheses.>

<Optional: You can also include a description of each section of this report as a last paragraph.>

```{r}
survey_data %>% group_by(cps21_votechoice) %>% summarise(n = n())
```

```{r}
survey_data %>% group_by(cps21_province) %>% summarise(n = n())
```
o Alberta (1)
o British Columbia (2)
o Manitoba (3)
o New Brunswick (4)
o Newfoundland and Labrador (5)
o Northwest Territories (6) reject
o Nova Scotia (7)
o Nunavut (8) reject
o Ontario (9)
o Prince Edward Island (10)
o Quebec (11)
o Saskatchewan (12)
o Yukon (13) reject

```{r}
census_data %>% group_by(province) %>% summarise(n = n())

```



```{r}
survey_data %>% group_by(cps21_age) %>% summarise(n = n())
census_data %>% group_by(age) %>% summarise(n = n())
```
```{r}
sum(is.na(survey_data$cps21_children))
survey_data %>% group_by(cps21_children) %>% summarise(n = n()) #remove 7 Don't know/ Prefer not to answer
# in survey_data: 1 means 0 child, 2 means 1 child, ... 6 means five or more kids. 7 means unknow
census_data %>% group_by(total_children) %>% summarise(n = n()) 

```

```{r}

df_sv_income <- tibble(x=survey_data$cps21_income_number) # famaily income

ggplot(data = df_sv_income, aes(x = x)) +
  geom_histogram(bins = 1000,fill = "blue", color = "black") +
  xlim(c(-1000,1000000)) +
  labs(title = "Histogram",
       x = "Value",
       y = "Frequency")

df_ces_income <- census_data %>% group_by(income_family) %>% summarise(n = n()) # famaily income

ggplot(df_ces_income, aes(x = income_family, y = n)) +
  geom_bar(stat = "identity", fill = "grey") +
  labs(title = "Bar Plot",
       x = "Category",
       y = "Value") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
df_ces_income 
```



## Data

<Type here a paragraph introducing the data, its context and as much info about the data collection process that you know.>


```{r, include = FALSE}

# Here you can load in and clean the census data (you may need to do the cleaning in a separate R script). 

census_data <- read_csv("gss_clean.csv")

# You may need additional chunks, in case you want to include some of the cleaning output.


```



<Type here a summary of the cleaning process (**only add in stuff beyond my original gss_cleaning.R code**). You only need to describe additional cleaning that you and your group did.> ] You will need to describe the cleaning you do to the survey data as well. 


```{r, include = FALSE}

# Here you can load in and clean the survey data. 
# All cleaning must be done in the same Rmd file as your final report. 
# All cleaning must not be shown in the submitted pdf. 
# Setting the cleaning chunk to include = FALSE will allow for this. 

load('ces2021.RData')

## The data dictionary is found in '2021 Canadian Election Study Codebook.pdf'
## In the data dictionary you can find the survey questions/responses corresponding to the column names in survey_data. 
## For example 

# cps21_age: Respondent age in years. Calculated from cps21_yob.
## cps21_votechoice: "Which party do you think you will vote for? - Selected Choice"

## Furthermore, when you select a variable in the survey_data, you will also see a description of the variable!. 
## If it's a categorical variable, you'll also see how it's coded! 
## For example: 

# suvey_data$cps21_votechoice
# attr(,"label")
# [1] "Which party do you think you will vote for? - Selected Choice"
# attr(,"format.stata")
# [1] "%32.0g"
# attr(,"class")
# [1] "haven_labelled"
# attr(,"labels")
#                    Liberal Party               Conservative Party                              ndp 
#                                1                                2                                3 
#                   Bloc Québécois                      Green Party   Another party (please specify) 
#                                4                                5                                6 
# Don't know/ Prefer not to answer 
#                                7 


```




```{r, include = FALSE}

#### You will need to update/clean the code below based off the variables you want to use in your poststratification.

survey_data_clean <- 
  survey_data %>% 
  filter(cps21_age >= 18) %>%
  filter(cps21_citizenship == 1) %>%
  mutate(vote_liberal = ifelse(cps21_votechoice==1, 1, 0),
         vote_Conservative = ifelse(cps21_votechoice==2, 1, 0),
         vote_ndp = ifelse(cps21_votechoice==3, 1, 0),
         province = case_when(cps21_province == 1 ~ "Alberta",
                            cps21_province == 2 ~ "British Columbia", 
                            cps21_province == 3 ~ "Manitoba",
                            cps21_province == 4 ~ "New Brunswick",
                            cps21_province == 5 ~ "Newfoundland and Labrador",
                            cps21_province == 6 ~ NA,
                            cps21_province == 7 ~ "Nova Scotia",
                            cps21_province == 8 ~ NA,
                            cps21_province == 9 ~ "Ontario",
                            cps21_province == 10 ~ "Prince Edward Island",
                            cps21_province == 11 ~ "Quebec",
                            cps21_province == 12 ~ "Saskatchewan",
                            cps21_province == 13 ~ NA),
         age = case_when(cps21_age >= 18 & cps21_age < 25 ~ "18-25",
                         cps21_age >= 25 & cps21_age < 30 ~ "25-30",
                         cps21_age >= 30 & cps21_age < 35 ~ "30-35",
                         cps21_age >= 35 & cps21_age < 40 ~ "35-40",
                         cps21_age >= 40 & cps21_age < 45 ~ "40-45",
                         cps21_age >= 45 & cps21_age < 55 ~ "45-55",
                         cps21_age >= 55 & cps21_age < 65 ~ "55-65",
                         cps21_age >= 65  ~ "65 and above"
                         ),
         
         income_family = case_when(cps21_income_number <= 25000 ~ "Less than $25,000",
                            cps21_income_number >= 25000 & cps21_income_number <= 49999 ~ "$25,000 to $49,999", 
                            cps21_income_number >= 50000 & cps21_income_number <= 74999 ~ "$50,000 to $74,999",
                            cps21_income_number >= 75000 & cps21_income_number <= 99999 ~ "$75,000 to $99,999",
                            cps21_income_number >= 100000 & cps21_income_number <= 124999 ~ "$100,000 to $ 124,999",
                            cps21_income_number >= 125000 ~ "$125,000 and more"),
         sex = case_when(cps21_genderid == 1 ~ "Male", 
                         cps21_genderid == 2 ~ "Female",
                         TRUE ~ NA)) %>% 
  select(vote_liberal, 
         vote_Conservative,
         vote_ndp,
         province, age, income_family, sex) %>%
  na.omit()    # This might not be the correct thing to do. 

census_data_clean <- census_data %>% 
  filter(age >= 18) %>% 
  filter(citizenship_status == "By birth" | citizenship_status =="By naturalization") %>%
  mutate(age = case_when(age >= 18 & age < 25 ~ "18-25",
                         age >= 25 & age < 30 ~ "25-30",
                         age >= 30 & age < 35 ~ "30-35",
                         age >= 35 & age < 40 ~ "35-40",
                         age >= 40 & age < 45 ~ "40-45",
                         age >= 45 & age < 55 ~ "45-55",
                         age >= 55 & age < 65 ~ "55-65",
                         age >= 65  ~ "65 and above"
                         )
         ) %>% 
  select(province, age, income_family, sex) %>%
  na.omit()


```




<Remember, you may want to use multiple datasets here, if you do end up using multiple data sets, or merging the data, be sure to describe this in the cleaning process and be sure to discuss important aspects of all the data that you used.>



<Include a description of the important variables.> 

```{r}

# Use this to calculate some summary measures. 
df_agetest <-
  survey_data_clean %>%   
  group_by(age) %>% 
    summarise(p=mean(vote_liberal)) 

ggplot(df_agetest, 
       aes(y= age, x = p))+
  geom_bar(stat = "identity", fill = "grey") +
  coord_flip() +  # Flip the plot horizontally
  labs(title = "..........",
       x = "Mean support rate for liberal party
       ",
       y = "Age group") +  # Flip x and y axis labels
  theme_minimal() 
```

```{r}
tablesex <-
  survey_data_clean %>%
  group_by(sex) %>%
  summarise("Counts" = n(), 
            "Numver of Voting liberal party" =  sum(vote_liberal), 
            "Support rate" = sum(vote_liberal)/Counts)
kable(tablesex, caption = "")
```


```{r, warning=FALSE, message=FALSE}
df_incometest <-
  survey_data_clean %>%   
  group_by(income_family, province) %>% 
    summarise(p=mean(vote_liberal), .groups = "drop") %>% mutate(Index = row_number())



ggplot(df_incometest, aes(x=Index, y=p))+
  geom_bar(stat = "identity", fill = "grey") +
  labs(title = "Bar Plot with Row Indices",
       x = "Row Index",
       y = "Mean Support Rate") +
  theme_minimal()
  
```



<Include a description of the numerical summaries. Remember you can use `r ` to use inline R code.>

```{r, echo = TRUE, fig.width=7, fig.height=2, fig.align='center'}

# Use this to create some plots. Should probably describe both the sample and population.


survey_province_prop <- 
  survey_data_clean %>% group_by(province) %>%
  summarise(n = n()) %>% 
  mutate('propotion in survey data' = n/sum(n))

census_province_prop <- 
  census_data_clean %>% group_by(province) %>%
  summarise(n = n()) %>% 
  mutate('propotion in census data' = n/sum(n))  

kable(cbind(survey_province_prop[,1], survey_province_prop[,3], census_province_prop[,3]))
```


```{r}
library(ggplot2)
library(gridExtra)
survey_age_prop <- 
  survey_data_clean %>% group_by(age) %>%
  summarise(n = n()) %>% 
  mutate('propotion in survey data' = n/sum(n))

census_age_prop <- 
  census_data_clean %>% group_by(age) %>%
  summarise(n = n()) %>% 
  mutate('propotion in census data' = n/sum(n))  

age_prop <-
  cbind(survey_age_prop[,1], survey_age_prop[,3], census_age_prop[,3])

age_prop

p1 <-
  ggplot(age_prop, aes(x=age, y=`propotion in survey data`))+
  geom_bar(stat = "identity", fill = "grey") +
  labs(title = "The propotion of each group in survey data",
       x = "age group",
       y = "propotion") +
  theme_minimal()

p2 <-
  ggplot(age_prop, aes(x=age, y=`propotion in census data`))+
  geom_bar(stat = "identity", fill = "grey") +
  labs(title = "The propotion of each group in census data",
       x = "age group",
       y = "propotion") +
  theme_minimal()

grid.arrange(p1, p2, ncol = 1)
```


## Methods 
To predict which parties will win the election, we fit a logistic regression with random-effect on intercept using the glmer function from the "lme4" package and logit as link function.

This specific model is designed to analyze the relationship between the dependent binary variable (vote the party or not) and several independent variables, including age, sex, and a random effect related to the combination of province and family income. 

The 5 binary response variables denote whether an individual voted for the that corresponding party (1 for yes, 0 for no).

Thus, we will have 5 models with same structure but different responses. Each of them can estimate the proportion of voting its corresponding party. 

We will apply post-stratification for the estimates from 5 models to adjust for the issues of non-response or non-probability sampling. After that, we can get 5 $\hat{y}^{P S}$: the overall weighted estimated proportion of voting for each party. The party with the highest proportion will be predicted to win the election. 


### Model Specifics

We fitted a logistic mixed model to predict the proportion of voting with age and sex (vote ~ age + sex). The model included a random effect related to the combination of province and family income as random effects on intercept.

$$\begin{aligned}
\text log(\frac{p}{1-p}) &= \beta_{0j} +  \beta_1 I^{\text{25-30age}}_{\text{ij}} + \beta_2 I^{\text{30-35age}}_{\text{ij}} + \beta_3 I^{\text{35-40age}}_{\text{ij}} + \beta_4 I^{\text{40-45age}}_{\text{ij}} + \beta_5 I^{\text{45-55age}}_{\text{ij}} + \beta_6 I^{\text{55-65age}}_{\text{ij}} + \beta_7 I^{\text{over65}}_{\text{ij}} + \beta_8 SEX_{\text{ij}}\\
\beta_{0j} &\sim \text{Normal}(\mu_{\beta_0},\sigma_{\beta_0}^2)\\
\end{aligned}$$


$p$ represents the proportion of voting for the specific party.
$\beta_{0j}$ represents a Random Intercept that affected by the combination of province and income_family.
$I_{ij}$ is the indicator that if the observation is in the particular age group (Yes = 1, No = 0). 
$SEX_{\text{ij}}$ is a categorical variable: male or female.
$\beta_1$ to $\beta_8$ are the coefficients of these variables.

Since we want to fit a logistic regression with random-effect on intercept, we will have the following assumptions: 

Linearity of the Log-Odds: The logistic link function used in the model assumes that the relationship between the predictors and the log-odds of the response variable is linear. 

Independence of Observations: Each observation in the dataset should be independent of the others.

Appropriate Random Effects Structure: The specification of random effects, in this case, (1|province:income_family), should accurately reflect the structure of the data. We need to ensure that it is justified and that it accounts for any correlations or nesting in the data

After we build the initial model, we will consider how to choose a better model or drop the variable(s) that does not significantly impact the response. We will use AIC and BIC as critera to compare different models and choose the one that best balances goodness of fit. If AIC and BIC are lower, after a change for the model, it typically indicates an improvement in the model's fit to the data. 

```{r, include=F}
# Creating the Model
mod1 <-
  glmer(vote_liberal ~ age  +  sex + (1|province:income_family),
      data = survey_data_clean,
      family = binomial(link = "logit"))
```

```{r, fig.width= 3, include=FALSE}
library(report)
report(mod1)
#province:income_family
report_table(mod1)[,1:9]
summary(mod1)
```


```{r, include=F}
mod2 <-
  glmer(vote_liberal ~ age +  (1|province:income_family),
      data = survey_data_clean,
      family = binomial(link = "logit"))
summary(mod2)

report_table(mod2)[,1:9]
```



## Post-Stratification 

Post-stratification is a technique used in survey analysis to improve the accuracy of estimates by adjusting for differences in non-probability sampling and non-response bias. It involves dividing the population into strata based on certain characteristics (variables) and then weighting the observations in each stratum to account for different estimates and sum them up to get a overall average.

In our logistic regression with random-effect on intercept for predicting voting proportion, we can apply post-stratification.

In order to estimate the proportion of voting one party, we group our cleaned census data by the variables we use as predictors in our regression models. For example, if we use age, province and income_family as our predictors, then we will group our data by these predictors. Each rows after grouping is cell/stratum and has its own combination of age group, province and family income level. Use summarise function to record the stratum size for each stratum. 

$$
\hat{y}^{P S}=\frac{\sum N_{j} \widehat{y}_{j}}{\sum N_{j}}
$$

Then, fit our regression model for each stratum to get the estimates and weight these estimates by its sample size based on the formula above. $\widehat{y}_{j}$ is the estimated proportion of voting one specific party for jth stratum. $N_{j}$ is the sample size for jth stratum. $\sum N_{j}$ is the total size in cleaned census data. Last but not least, $\hat{y}^{P S}$ is the overall weighed proportion of voting one specific party by Post-Stratification.

Since we have 5 regression models, we will get the proportion of voting the 5 parties by Post-Stratification. The party with the highest proportion will be predicted to win the election. 


All analysis for this report was programmed using `R version 4.0.2`. 



## Results 
```{r, include=F}
report(mod1)
report(mod2)
```
Since the models for predicting all 5 major political parties will be the same, for simplicity, we will showcase our model selection process using the model for Liberal party only. 

After we fit the initial model:
$$\begin{aligned}
\text log(\frac{p}{1-p}) &= \beta_{0j} +  \beta_1 I^{\text{25-30age}}_{\text{ij}} + \beta_2 I^{\text{30-35age}}_{\text{ij}} + \beta_3 I^{\text{35-40age}}_{\text{ij}} + \beta_4 I^{\text{40-45age}}_{\text{ij}} + \beta_5 I^{\text{45-55age}}_{\text{ij}} + \beta_6 I^{\text{55-65age}}_{\text{ij}} + \beta_7 I^{\text{over65}}_{\text{ij}} + \beta_8 SEX_{\text{ij}}\\
\beta_{0j} &\sim \text{Normal}(\mu_{\beta_0},\sigma_{\beta_0}^2)\\
\end{aligned}$$

The outcome of the model for liberal party is showed on this table:

Parameter          | Coefficient |         95% CI |      z |      p | Effects |                 
-------------------|-------------|----------------|--------|--------|---------|
(Intercept)        |       -1.51 | [-1.71, -1.31] | -14.66 | < .001 |   fixed |                       
age [25-30]        |        0.05 | [-0.17,  0.28] |   0.48 | 0.633  |   fixed |                       
age [30-35]        |        0.37 | [ 0.16,  0.58] |   3.40 | < .001 |   fixed |                       
age [35-40]        |        0.51 | [ 0.29,  0.72] |   4.66 | < .001 |   fixed |                       
age [40-45]        |        0.41 | [ 0.20,  0.62] |   3.77 | < .001 |   fixed |                       
age [45-55]        |        0.47 | [ 0.28,  0.65] |   4.85 | < .001 |   fixed |                       
age [55-65]        |        0.57 | [ 0.38,  0.75] |   6.04 | < .001 |   fixed |                       
age [65 and above] |        0.65 | [ 0.47,  0.83] |   7.12 | < .001 |   fixed |                       
sex [Male]         |       -0.03 | [-0.10,  0.05] |  -0.70 | 0.484  |   fixed |                       
province:income_family|     0.39 |                |        |        |  random | 
                   |             |                |        |        |         |                       
AIC                |     16535.3 |                |        |        |         |                       
BIC                |     16611.1 |                |        |        |         |                       
logLik             |     -8257.6 |                |        |        |         |                       
Table: Summary of model 1 for liberal party

We choose age and sex as the fixed effects and the combination of province and family income level as the random intercept. It is noticeable that the p-value for predictor sex is quite large, which means we have strong evidence that sex is not a significant predictor for the response. Thus, we drop the variable sex. And refit the model.

There is our reduced model look like:
$$\begin{aligned}
\text log(\frac{p}{1-p}) &= \beta_{0j} +  \beta_1 I^{\text{25-30age}}_{\text{ij}} + \beta_2 I^{\text{30-35age}}_{\text{ij}} + \beta_3 I^{\text{35-40age}}_{\text{ij}} + \beta_4 I^{\text{40-45age}}_{\text{ij}} + \beta_5 I^{\text{45-55age}}_{\text{ij}} + \beta_6 I^{\text{55-65age}}_{\text{ij}} + \beta_7 I^{\text{over65}}_{\text{ij}} \\
\beta_{0j} &\sim \text{Normal}(\mu_{\beta_0},\sigma_{\beta_0}^2)\\
\end{aligned}$$

The outcome of the reduced model for liberal party is showed on this table:

Parameter          | Coefficient |         95% CI |      z |      p | Effects |                  
-------------------|-------------|----------------|--------|--------|---------|
(Intercept)        |       -1.52 | [-1.72, -1.32] | -14.79 | < .001 |   fixed |                       
age [25-30]        |        0.05 | [-0.17,  0.28] |   0.47 | 0.641  |   fixed |                       
age [30-35]        |        0.37 | [ 0.15,  0.58] |   3.38 | < .001 |   fixed |                       
age [35-40]        |        0.50 | [ 0.29,  0.72] |   4.63 | < .001 |   fixed |                       
age [40-45]        |        0.40 | [ 0.19,  0.62] |   3.73 | < .001 |   fixed |                       
age [45-55]        |        0.46 | [ 0.27,  0.65] |   4.81 | < .001 |   fixed |                       
age [55-65]        |        0.56 | [ 0.38,  0.74] |   6.00 | < .001 |   fixed |                       
age [65 and above] |        0.65 | [ 0.47,  0.82] |   7.09 | < .001 |   fixed |                       
province:income_family|     0.39 |                |        |        |  random | 
                   |             |                |        |        |         |                       
AIC                |     16533.8 |                |        |        |         |                       
BIC                |     16602.0 |                |        |        |         |                       
logLik             |     -8257.9 |                |        |        |         |     
Table: Summary of reduced model for liberal party

After dropping variable sex, the model has lower AIC and BIC. Indicating that the modified model is a better fit to the data and may be a more suitable choice for analysis or prediction. So we choose the reduced model to be our final model. 


```{r, include=FALSE}

# Creating the Model
# Model Results (to Report in Results section)
# summary(model)
# OR
# broom::tidy(model)

mod2_liberal <-
  glmer(vote_liberal ~ age +  (1|province:income_family),
      data = survey_data_clean,
      family = binomial(link = "logit"))

mod2_Conservative <-
  glmer(vote_Conservative ~ age +  (1|province:income_family),
      data = survey_data_clean,
      family = binomial(link = "logit"))

mod2_ndp <-
  glmer(vote_ndp ~ age +  (1|province:income_family),
      data = survey_data_clean,
      family = binomial(link = "logit"))

```

With our final model determined, we then performed poststratification using population demographics. As described in the Methods Section, we poststratified our population with respects to age groups, provinces, and family incomes. Hence, we had a total of $8 * 6 * 12 = 576$ strata (8 age groups, 6 levels of family income, 12 provinces). The estimated means ($\widehat{y}_{j}$) for each stratum ($j$) were calculated, but due to the large number of strata, we will not present the estimates. *should we attach the census_data_counts? if so, mention supplementary material section*

```{r, include=FALSE}

# Here I will perform the post-stratification calculation
census_data_counts <- census_data_clean %>% 
  group_by(age,province,income_family) %>% 
  summarise(n=n(), .groups = "drop")

########################################################
census_data_counts$estimate_liberal <-
  mod2_liberal %>%
  predict(newdata = census_data_counts, type = "response")

census_data_counts$estimate_Conservative <-
  mod2_Conservative %>%
  predict(newdata = census_data_counts, type = "response")

census_data_counts$estimate_ndp <-
  mod2_ndp %>%
  predict(newdata = census_data_counts, type = "response")
```

Then, we calculated the $\hat{y}^{P S}$ for the three major political parties, i.e., Liberal, Conservative, and NPD. The results were shown in the following table: 

```{r}
census_table <- census_data_counts %>% 
  mutate(liberal_predict_prop = estimate_liberal*n,
         Conservative_predict_prop = estimate_Conservative*n,
         ndp_predict_prop = estimate_ndp*n) %>%
  summarise(liberal_predict = sum(liberal_predict_prop)/sum(n), #proportions
            Conservative_predict = sum(Conservative_predict_prop)/sum(n),
            ndp_predict = sum(ndp_predict_prop)/sum(n)
            ) %>%
  pivot_longer(
    cols = everything(), 
    names_to = "Political Party", 
    values_to = "Predicted Proportion of Votes"
  ) %>%
  mutate(`Political Party` = c("Liberal", "Conservative", "NDP"))

kable(census_table)
```

As can be seen from the table, our models predicted that there will be `r liberal_predict * 100`% voters voting for the Liberal Party, `r Conservative_predict * 100`% voting for the Conservative Party, and `r ndp_predict * 100`% voting for the NDP. Together, the three major political parties take approximately `r (liberal_predict + Conservative_predict + ndp_predict) *100`% of the total votes, suggesting little likelihood that other parties will have votes higher than any of the three. Therefore, the prediction indicates that the Liberal Party is the most likely party to win the election because it has the largest predicted proportion of voters voting for them. 

Our results are plausible both methodologically and practically. From the methodological perspective, we carefully selected our potential predictor variables and calibrated our model by removing redundant variable(s). Further, we employed multi-level regression method when building our model, which takes random variations at both individual and group levels (e.g., age groups), enabling precise pinpoints at the estimates. When generating prediction, we stratified the population with respect to all of the three predictor variables (i.e., age groups, provinces, and levels of income). With the thorough and refined methods, we are confident with our predictions. 

More importantly, our predictions were consistent with the real-world situation. For example, results from 2019 Canadian Election were that the Liberal Party won the election with the largest proportion of votes (39.47%), followed by the Conservative Party (31.89%) and the NDP (19.71%). The trend showed in 2019 election results was identical to the trend in our prediction. Therefore, with calibrated statistical methods and real-world confirmations, our predictions should be of relatively high reliability and plausibility. 



## Conclusions

<Here you should give a summary of the Hypotheses, Methods and Results>

<Highlight Key Results.>

<Talk about big picture.>

<Comment on any Weaknesses.>

<Comment on Future Work/Next Steps>

<End with a concluding paragraph to wrap up the report.>


## Bibliography

1. Grolemund, G. (2014, July 16) *Introduction to R Markdown*. RStudio. [https://rmarkdown.rstudio.com/articles_intro.html](https://rmarkdown.rstudio.com/articles_intro.html). (Last Accessed: April 4, 1991) 

2.  RStudio Team. (2020). *RStudio: Integrated Development for R*. RStudio, PBC, Boston, MA URL [http://www.rstudio.com/](http://www.rstudio.com/).

3.  Allaire, J.J., et. el. *References: Introduction to R Markdown*. RStudio. [https://rmarkdown.rstudio.com/docs/](https://rmarkdown.rstudio.com/docs/). (Last Accessed: April 4, 1991) 

4. OpenAI. (2023). *ChatGPT (September 13 version) [Large language model]*. [https://chat.openai.com/chat](https://chat.openai.com/chat) (Last Accessed: September 13, 2023)

\newpage

## Appendix

## Generative AI Statement

Here is where you can explain your usage of Generative AI tool(s). Be sure to reference it. For instance, including something like: 

I used the following generative artificial intelligence (AI) tool: Bing AI Version 2.0 for Chrome [4]. I used the tool only in the Results section of this assignment and I gave it the following prompt of `What should I eat for breakfast?` and it gave me a list of 10 breakfast items which I then asked it to: `Please only list breakfast items that do not include eggs`. I then chose my 3 favourite items from the produced list and included those in the Results section.


### Supplementary Materials

<Here you can include any additional plots, tables, derivations, etc.>
